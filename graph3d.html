<!DOCTYPE html>
<html lang="en">

<head>
	<title>3D Bar Chart of Moonquakes</title>
	<link rel="icon" type="image/x-icon" href="/icon/favicon.ico">
	<script type="text/javascript" src="moon_quakes.json"></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
	<div id="container"></div>
	<!-- <div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - cascaded shadow maps<br>
		by <a href="https://github.com/strandedkitty/" target="_blank" rel="noopener">StrandedKitty</a> (<a
			href="https://github.com/strandedkitty/three-csm" target="_blank" rel="noopener">original repository</a>)
	</div> -->

	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>

	<style>
		.label {
			color: #FFF;
			font-family: sans-serif;
			font-size: 24px;
			padding: 2px;
			background: rgba(0, 0, 0, .6);
		}
	</style>

	<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

	<script type="module">

		import * as THREE from 'three';

		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import { CSM } from 'three/addons/csm/CSM.js';
		import { CSMHelper } from 'three/addons/csm/CSMHelper.js';
		import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

		let renderer, scene, camera, orthoCamera, controls, csm, csmHelper, labelRenderer;
		var yearLista = [];
		// var dayLista = [];
		// var intensityLista = [];

		const params = {
			orthographic: false,
			fade: false,
			far: 1000,
			mode: 'practical',
			lightX: - 1,
			lightY: - 1,
			lightZ: - 1,
			margin: 100,
			lightFar: 5000,
			lightNear: 1,
			autoUpdateHelper: true,
			// updateHelper: function () {

			// 	csmHelper.update();

			// }
			info: function () {
			},
			backMoon: function () {
				window.open("indexb.html", "_self"); // back to the moon
			}
		};

		init();
		animate();

		function updateOrthoCamera() {

			const size = controls.target.distanceTo(camera.position);
			const aspect = camera.aspect;

			orthoCamera.left = size * aspect / - 2;
			orthoCamera.right = size * aspect / 2;

			orthoCamera.top = size / 2;
			orthoCamera.bottom = size / - 2;
			orthoCamera.position.copy(camera.position);
			orthoCamera.rotation.copy(camera.rotation);
			orthoCamera.updateProjectionMatrix();

		}

		function init() {

			scene = new THREE.Scene();
			scene.background = new THREE.Color('#454e61');
			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);
			orthoCamera = new THREE.OrthographicCamera();

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;


			// Para los labels
			labelRenderer = new CSS2DRenderer();
			labelRenderer.setSize(window.innerWidth, window.innerHeight);
			labelRenderer.domElement.style.position = 'absolute';
			labelRenderer.domElement.style.top = '0px';
			document.body.appendChild(labelRenderer.domElement);

			// controls = new OrbitControls(camera, renderer.domElement);
			controls = new OrbitControls(camera, labelRenderer.domElement);
			controls.maxPolarAngle = Math.PI / 2;
			camera.position.set(60, 60, 0);
			controls.target = new THREE.Vector3(- 100, 10, 0);
			controls.update();



			const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
			scene.add(ambientLight);

			const additionalDirectionalLight = new THREE.DirectionalLight(0x000020, 1.5);
			additionalDirectionalLight.position.set(params.lightX, params.lightY, params.lightZ).normalize().multiplyScalar(- 200);
			scene.add(additionalDirectionalLight);

			csm = new CSM({
				maxFar: params.far,
				cascades: 4,
				mode: params.mode,
				parent: scene,
				shadowMapSize: 1024,
				lightDirection: new THREE.Vector3(params.lightX, params.lightY, params.lightZ).normalize(),
				camera: camera
			});

			csmHelper = new CSMHelper(csm);
			csmHelper.visible = false;
			scene.add(csmHelper);

			const floorMaterial = new THREE.MeshPhongMaterial({ color: '#252a34' });
			csm.setupMaterial(floorMaterial);

			const floor = new THREE.Mesh(new THREE.PlaneGeometry(10000, 10000, 8, 8), floorMaterial);
			floor.rotation.x = - Math.PI / 2;
			floor.castShadow = true;
			floor.receiveShadow = true;
			scene.add(floor);

			const gui = new GUI({ width: 340 });

			// gui.add(params, 'orthographic').onChange(function (value) {

			// 	csm.camera = value ? orthoCamera : camera;
			// 	csm.updateFrustums();

			// });

			// gui.add(params, 'fade').onChange(function (value) {

			// 	csm.fade = value;
			// 	csm.updateFrustums();

			// });

			// gui.add(params, 'far', 1, 5000).step(1).name('shadow far').onChange(function (value) {

			// 	csm.maxFar = value;
			// 	csm.updateFrustums();

			// });

			// gui.add(params, 'mode', ['uniform', 'logarithmic', 'practical']).name('frustum split mode').onChange(function (value) {

			// 	csm.mode = value;
			// 	csm.updateFrustums();

			// });

			// gui.add(params, 'lightX', - 1, 1).name('light direction x').onChange(function (value) {

			// 	csm.lightDirection.x = value;

			// });

			// gui.add(params, 'lightY', - 1, 1).name('light direction y').onChange(function (value) {

			// 	csm.lightDirection.y = value;

			// });

			// gui.add(params, 'lightZ', - 1, 1).name('light direction z').onChange(function (value) {

			// 	csm.lightDirection.z = value;

			// });

			// gui.add(params, 'margin', 0, 200).name('light margin').onChange(function (value) {

			// 	csm.lightMargin = value;

			// });

			// gui.add(params, 'lightNear', 1, 10000).name('light near').onChange(function (value) {

			// 	for (let i = 0; i < csm.lights.length; i++) {

			// 		csm.lights[i].shadow.camera.near = value;
			// 		csm.lights[i].shadow.camera.updateProjectionMatrix();

			// 	}

			// });

			// gui.add(params, 'lightFar', 1, 10000).name('light far').onChange(function (value) {

			// 	for (let i = 0; i < csm.lights.length; i++) {

			// 		csm.lights[i].shadow.camera.far = value;
			// 		csm.lights[i].shadow.camera.updateProjectionMatrix();

			// 	}

			// });

			// const helperFolder = gui.addFolder('helper');

			// helperFolder.add(csmHelper, 'visible');

			// helperFolder.add(csmHelper, 'displayFrustum').onChange(function () {

			// 	csmHelper.updateVisibility();

			// });

			// helperFolder.add(csmHelper, 'displayPlanes').onChange(function () {

			// 	csmHelper.updateVisibility();

			// });

			// helperFolder.add(csmHelper, 'displayShadowBounds').onChange(function () {

			// 	csmHelper.updateVisibility();

			// });

			// gui.add(params, 'autoUpdateHelper').name('auto update');
			gui.add(params, 'info').name('Info Info: Hold down the right mouse button = Rotate');
			gui.add(params, 'info').name('Info: Hold down the Left mouse button = Move');
			gui.add(params, 'info').name('Info: Mouse wheel = Zoom');
			gui.add(params, 'info').name('Info Format YYYY-DD Intensity');
			gui.add(params, 'backMoon').name('Back to the Moon');

			gui.open();

			window.addEventListener('resize', function () {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				labelRenderer.setSize(window.innerWidth, window.innerHeight);

				updateOrthoCamera();
				csm.updateFrustums();

				renderer.setSize(window.innerWidth, window.innerHeight);

			});

			moonQuakeLoadTIME();

		}

		function moonQuakeLoadTIME() {
			//fetch function Para moon_landing
			// let datos;

			fetch('moon_quakes.json').then(
				function (u) { return u.json(); }
			).then(
				function (json) {
					data_function(json); //calling and passing json to another function data_function
					// yearLista.push(2010);
				}
			)
			//another functions oon_landing
			function data_function(data) {
				// alert(data.length);

				// addMarker(data[0].lat, data[0].lng, "", data[0].label);
				// Cargamos todo
				Object.entries(data).forEach(([key, value]) => {
					// console.log("Label", data[key].label, data[key].lat, data[key].lng);
					// addMarker(data[key].lat, data[key].lng, 'rgb(255, 0, 0)', data[key].label, dmodelo, MOON_RADIUS, 7, "moonquake");
					// Coordenadas
					// console.log(data[key].label);
					// console.log(`${key} ${value}`);
					// console.log(data[key].year, " ", data[key].day);
					// graphMegnitude(data[key].year, data[key].day, data[key].intensity, orden);
					yearLista.push([data[key].year, data[key].day, data[key].intensity]);
					// dayLista.push(parseInt(data[key].day));
					// intensityLista.push(parseInt(data[key].intensity));
				});
				// initGui(yearLista, dayLista);
				graphMegnitude(yearLista);
			}
		}

		function graphMegnitude(yearLista) {

			// console.log(yearLista);
			yearLista.sort();

			const material1 = new THREE.MeshPhongMaterial({ color: '#2bff00' });
			csm.setupMaterial(material1);

			const material2 = new THREE.MeshPhongMaterial({ color: '#0011ff' });
			csm.setupMaterial(material2);

			const geometry = new THREE.BoxGeometry(10, 5, 10);

			for (var i = 0; i < yearLista.length; i++) {

				// Add label
				const yearDiv = document.createElement('div');
				yearDiv.className = 'label';
				yearDiv.textContent = yearLista[i][0].toString() + "-" + yearLista[i][1].toString();
				yearDiv.style.backgroundColor = '0x000000';
				// earthDiv.style.textColor = '0x000000';

				const yearLabel = new CSS2DObject(yearDiv);
				yearLabel.position.set(-i * 25, 5, 30);
				// earthLabel.position.set(50, 50, 50);
				// earthLabel.position.set(convertLatLonToVec3(lat, lon).multiplyScalar(MOON_RADIUS));
				yearLabel.center.set(0.5, -2);
				scene.add(yearLabel);

				const yearDivb = document.createElement('div');
				yearDivb.className = 'label';
				yearDivb.textContent = "I: " + yearLista[i][2].toString();
				yearDivb.style.backgroundColor = '0x000000';
				// earthDiv.style.textColor = '0x000000';

				const yearLabelb = new CSS2DObject(yearDivb);
				yearLabelb.position.set(-i * 25, 5, 30);
				// earthLabel.position.set(50, 50, 50);
				// earthLabel.position.set(convertLatLonToVec3(lat, lon).multiplyScalar(MOON_RADIUS));
				yearLabelb.center.set(0.5, -3);
				scene.add(yearLabelb);

				const cube1 = new THREE.Mesh(geometry, i % 2 === 0 ? material1 : material2);
				cube1.castShadow = true;
				cube1.receiveShadow = true;
				scene.add(cube1);
				cube1.position.set(- i * 25, -14.9, 30);
				// cube1.scale.y = Math.random() * 2 + 6;
				cube1.scale.y = yearLista[i][2] * 2 + 6;

				// const cube2 = new THREE.Mesh(geometry, i % 2 === 0 ? material2 : material1);
				// cube2.castShadow = true;
				// cube2.receiveShadow = true;
				// scene.add(cube2);
				// cube2.position.set(- i * 25, 20, - 30);
				// cube2.scale.y = Math.random() * 2 + 6;
			}
		}

		function animate() {

			requestAnimationFrame(animate);

			camera.updateMatrixWorld();
			csm.update();
			controls.update();
			labelRenderer.render(scene, camera);

			if (params.orthographic) {

				updateOrthoCamera();
				csm.updateFrustums();

				if (params.autoUpdateHelper) {

					csmHelper.update();

				}

				renderer.render(scene, orthoCamera);

			} else {

				if (params.autoUpdateHelper) {

					csmHelper.update();

				}

				renderer.render(scene, camera);

			}

		}

	</script>

</body>

</html>