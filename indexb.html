<!DOCTYPE html>
<html>

<head>
	<script type="text/javascript" src="moon_landings.json"></script>
	<script type="text/javascript" src="seas.json"></script>
	<script type="text/javascript" src="moon_quakes.json"></script>
	<!-- <script src="https://d3js.org/d3.v5.min.js"></script> -->
	<!-- <script src="/js/mercer.js"></script> -->
	<!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script> -->

	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>Moonquake Map 3D</title>
	<link rel="icon" type="image/x-icon" href="./icon/favicon.ico">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		.label {
			color: #FFF;
			font-family: sans-serif;
			font-size: 24px;
			padding: 2px;
			background: rgba(0, 0, 0, .6);
		}
	</style>
</head>

<body>
	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<!-- <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script> -->
	<!-- <div id="line-graph-container" style="width:800px;height:600px;"></div> -->
	<div id="container"></div>

	<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

	<script type="module">

		import * as THREE from 'three';

		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
		import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
		import dat from "https://cdn.skypack.dev/dat.gui";

		// import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

		let mixeranim;
		var model3dquake, cube, model3dCubeApollo, GraphBtn, rotationSpeed, lightAmbient, lightPoint, ambientLightSlide, dirLightSlide;
		var rotationSpeedVal = 0;
		var ambientLightValue = 0, dirLightValue = 5, dirLightValueMovement = 0, dirLightSlideMov;
		// var textureMeshScale;

		const MOON_RADIUS = 0.995;

		// Labels moomquake
		var loaderquake;
		var earthSabel;
		var earthMabel;
		var earthLLabel;
		var earthLocabel;
		var earthHLabel;
		var earthydLabel;
		var earthLabel;

		const yearLista = [];
		const dayLista = [];
		// moonQuakeLoadTIME();

		// d3.json("moon_quakes.json").then(function (data_json) {
		// 	//do your stuff
		// 	jsonTemp = data_json;
		// 	// console.log(data_json);
		// 	loadjsonmoonquake(data_json);
		// });

		// var jsonTemp = [];
		// fetch('moon_quakes.json').then(response => jsonTemp = response.json());

		// console.log(jsonTemp);

		const dracoLoader = new DRACOLoader();
		dracoLoader.setDecoderPath('jsm/libs/draco/gltf/');

		// import Stats from 'three/addons/libs/stats.module.js';

		let gui;

		let camera, scene, renderer, labelRenderer, moon, sphereWire, skybox, o, moonMaterial, moonHeightMesh;
		let skyboxImage = "space";

		// Para las estadisticas fps y mem solo diag 
		// const container = document.getElementById('container');
		// const stats = new Stats();
		// container.appendChild(stats.dom);

		const layers = {

			'Toggle Name': function () {
				// Tierra
				camera.layers.toggle(0);

			},
			'Toggle Mass': function () {
				// Moon landing
				camera.layers.toggle(1);

			},
			'Enable All': function () {

				camera.layers.enableAll();

			},

			'Disable All': function () {

				camera.layers.disableAll();

			}

		};

		const clock = new THREE.Clock();
		const textureLoader = new THREE.TextureLoader();

		var earth, yMoonquake, dMoonquake;

		init();
		animate();

		function init() {

			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);

			camera.position.set(3, convertLatLonToVec3(0, 0).y, convertLatLonToVec3(0, 0).z);
			camera.layers.enableAll();

			scene = new THREE.Scene();

			// const dirLight = new THREE.DirectionalLight(0xffffff, 3);
			// dirLight.position.set(0, 0, 1);
			// dirLight.layers.enableAll();
			// scene.add(dirLight);

			// Luces
			lightAmbient = new THREE.AmbientLight(0xffffff); // soft white light
			lightAmbient.intensity = 0; // 0 = off 1 = on, 0.1
			scene.add(lightAmbient);

			lightPoint = new THREE.PointLight(0xffffff, 1, 100);
			lightPoint.position.set(1.2, convertLatLonToVec3(0, 0).y, convertLatLonToVec3(0, 0).z - 2);
			lightPoint.intensity = 55;
			scene.add(lightPoint);

			// Para mostraras ejes
			const axesHelper = new THREE.AxesHelper(10);
			axesHelper.layers.enableAll();
			scene.add(axesHelper);
			axesHelper.layers.set(2);
			camera.layers.toggle(2);

			//
			// Moon sphere
			const moonGeometry = new THREE.SphereGeometry(MOON_RADIUS, 16, 16);
			moonMaterial = new THREE.MeshPhongMaterial({
				specular: 0x333333,
				shininess: 5,
				map: textureLoader.load('./textures/lroc_color_poles_4k.jpg'),
				// specularMap: textureLoader.load('textures/planets/earth_specular_2048.jpg'),
				// normalMap: textureLoader.load('textures/planets/earth_normal_2048.jpg'),
				normalScale: new THREE.Vector2(0.85, 0.85)
			});


			moonMaterial.map.colorSpace = THREE.SRGBColorSpace;
			moon = new THREE.Mesh(moonGeometry, moonMaterial);
			scene.add(moon);

			// Moon sphere Height map
			const moonHeight = new THREE.SphereGeometry(MOON_RADIUS, 16, 16);
			moonMaterial = new THREE.MeshPhongMaterial({
				specular: 0x333333,
				shininess: 5,
				map: textureLoader.load('./textures/heightmapjpg.jpg'),
				// specularMap: textureLoader.load('textures/planets/earth_specular_2048.jpg'),
				// normalMap: textureLoader.load('textures/planets/earth_normal_2048.jpg'),
				normalScale: new THREE.Vector2(0.85, 0.85)
			});

			moonMaterial.map.colorSpace = THREE.SRGBColorSpace;
			moonHeightMesh = new THREE.Mesh(moonHeight, moonMaterial);
			scene.add(moonHeightMesh);
			moonHeightMesh.layers.set(6);
			camera.layers.toggle(6);

			// Moon sphere Wire Lat Long
			const g = new THREE.SphereGeometry(1, 16, 16);
			SphereToQuads(g);
			// console.log(g);
			let m = new THREE.LineBasicMaterial({ color: "blue" });
			o = new THREE.LineSegments(g, m);

			// Para mostraras lat long
			// wirematerial = new THREE.MeshBasicMaterial({
			// 	color: 0xff0000,
			// 	wireframe: true
			// });


			moon.layers.enableAll();
			// moon.layers.enableAll();

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			labelRenderer = new CSS2DRenderer();
			labelRenderer.setSize(window.innerWidth, window.innerHeight);
			labelRenderer.domElement.style.position = 'absolute';
			labelRenderer.domElement.style.top = '0px';
			document.body.appendChild(labelRenderer.domElement);

			const controls = new OrbitControls(camera, labelRenderer.domElement);
			controls.minDistance = 1.2;
			controls.maxDistance = 30;

			// Test image show escala mapa altura 
			// load the base texture
			// const textureScale1 = new THREE.TextureLoader().load('/textures/scale.jpg');

			// // create a new buffer geometry and place it
			// // to the horizontal plane
			// const scaleGeometry = new THREE.PlaneGeometry(0.3, 1);
			// scaleGeometry.rotateY(90 * THREE.MathUtils.DEG2RAD);
			// // translate the plane to the center of the scene
			// // scaleGeometry.translate(0.5, 0, -1.1);

			// // create a MeshBasicMaterial with the base texture
			// const textureMaterial = new THREE.MeshBasicMaterial({ map: textureScale1 });

			// // create a mesh using the geometry and material
			// // and add it to the scene
			// textureMeshScale = new THREE.Mesh(scaleGeometry, textureMaterial);
			// scene.add(textureMeshScale);
			// textureMeshScale.position.set(0.5, 0, -1.1);
			// textureMeshScale.layers.set(6);

			var loaderBox = new THREE.TextureLoader();
			loaderBox.load('./textures/scale.jpg', function (textureScale) {
				const geometryBox = new THREE.BoxGeometry(0.3, 1, 0.3);
				const materialBox = new THREE.MeshBasicMaterial({ color: 0xffffff, map: textureScale });
				const cubeScale = new THREE.Mesh(geometryBox, materialBox);
				cubeScale.position.set(0, 0, -1.5);
				cubeScale.layers.set(6);
				scene.add(cubeScale);
			});

			//
			// var json = (function () {
			// 	var json = null;
			// 	$.ajax({
			// 		'async': false,
			// 		'global': false,
			// 		'url': "/content.json",
			// 		'dataType': "json",
			// 		'success': function (data) {
			// 			json = data;
			// 		}
			// 	});
			// 	return json;
			// })();

			// console.log(json);

			setSkyBox();
			load3dmodels();
			seasLoad(MOON_RADIUS, "")
			moonLandingLoad(MOON_RADIUS, "./3dmodels/", "boxApollo.gltf");
			// Ocultamos los moonquakes
			// camera.layers.toggle(7);

			// Add markers
			// addMarker(0, 0, 0x0000ff, "Hola", "", MOON_RADIUS);
			// addMarker(60, 60, 0x0000ff, "Hola2", "", MOON_RADIUS);

			window.addEventListener('resize', onWindowResize);

			//usage:
			// readTextFile("moon_quakes.json", function (text) {
			// 	var data = JSON.parse(text);
			// 	yearLista.push(data[0].year);
			// 	// return data;
			// });
			moonQuakeLoadTIME();
			// initGui();


		}

		// function loadjsonmoonquake(json) {
		// 	jsonTemp = json;
		// }
		// function readTextFile(file, callback) {
		// 	var rawFile = new XMLHttpRequest();
		// 	rawFile.overrideMimeType("application/json");
		// 	rawFile.open("GET", file, true);
		// 	rawFile.onreadystatechange = function () {
		// 		if (rawFile.readyState === 4 && rawFile.status == "200") {
		// 			callback(rawFile.responseText);
		// 		}
		// 	}
		// 	rawFile.send(null);
		// }

		function SphereToQuads(g) {
			let p = g.parameters;
			let segmentsX = p.widthSegments;
			let segmentsY = p.heightSegments - 2;
			let mainShift = segmentsX + 1;
			let indices = [];
			for (let i = 0; i < segmentsY + 1; i++) {
				let index11 = 0;
				let index12 = 0;
				for (let j = 0; j < segmentsX; j++) {
					index11 = (segmentsX + 1) * i + j;
					index12 = index11 + 1;
					let index21 = index11;
					let index22 = index11 + (segmentsX + 1);
					indices.push(index11 + mainShift, index12 + mainShift);
					if (index22 < ((segmentsX + 1) * (segmentsY + 1) - 1)) {
						indices.push(index21 + mainShift, index22 + mainShift);
					}
				}
				if ((index12 + segmentsX + 1) <= ((segmentsX + 1) * (segmentsY + 1) - 1)) {
					indices.push(index12 + mainShift, index12 + segmentsX + 1 + mainShift);
				}
			}

			let lastIdx = indices[indices.length - 1] + 2;

			// poles
			for (let i = 0; i < segmentsX; i++) {
				//top
				indices.push(i, i + mainShift, i, i + mainShift + 1);

				// bottom
				let idx = lastIdx + i;
				let backShift = mainShift + 1;
				indices.push(idx, idx - backShift, idx, idx - backShift + 1);
			}

			g.setIndex(indices);
		}

		function seasLoad(MOON_RADIUS) {
			//fetch function Para moon_landing
			// let datos;
			fetch('seas.json').then(
				function (u) { return u.json(); }
			).then(
				function (json) {
					data_function(json); //calling and passing json to another function data_function
				}
			)
			//another functions oon_landing
			function data_function(data) {
				// alert(data.length);

				// addMarker(data[0].lat, data[0].lng, "", data[0].label);
				// Cargamos todo
				Object.entries(data).forEach(([key, value]) => {
					// console.log("Label", data[key].label, data[key].lat, data[key].lng);
					addMarker(data[key].lat, data[key].lng, 'rgb(0, 50, 255)', data[key].label, "", "", MOON_RADIUS, 3, "seas");
					// console.log(data[key].label);
					// console.log(`${key} ${value}`);
				});
				// datos = data;
			}
		}

		function moonQuakeLoadTIME() {
			//fetch function Para moon_landing
			// let datos;

			fetch('moon_quakes.json').then(
				function (u) { return u.json(); }
			).then(
				function (json) {
					data_function(json); //calling and passing json to another function data_function
					yearLista.push(2010);
				}
			)
			//another functions oon_landing
			function data_function(data) {
				// alert(data.length);

				// addMarker(data[0].lat, data[0].lng, "", data[0].label);
				// Cargamos todo
				Object.entries(data).forEach(([key, value]) => {
					// console.log("Label", data[key].label, data[key].lat, data[key].lng);
					// addMarker(data[key].lat, data[key].lng, 'rgb(255, 0, 0)', data[key].label, dmodelo, MOON_RADIUS, 7, "moonquake");
					// Coordenadas
					// console.log(data[key].label);
					// console.log(`${key} ${value}`);
					// console.log(data[key].year, " ", data[key].day);

					yearLista.push(parseInt(data[key].year));
					dayLista.push(parseInt(data[key].day));
				});
				initGui(yearLista, dayLista);
			}
		}
		function showArray(theArray) {
			// var quote = "";
			// for (var i = 0; i < theArray.length; i++) {
			// 	quote += theArray[i] + " ";
			// }
			console.log(theArray);
			return theArray;
		}

		function moonQuakeLoad(MOON_RADIUS, pathmodels, dmodelo, year, day, addremovemoonquake) {
			//fetch function Para moon_landing
			// let datos;
			fetch('moon_quakes.json').then(
				function (u) { return u.json(); }
			).then(
				function (json) {
					data_function(json); //calling and passing json to another function data_function
				}
			)
			//another functions oon_landing
			function data_function(data) {
				// alert(data.length);

				// addMarker(data[0].lat, data[0].lng, "", data[0].label);
				// Cargamos todo
				Object.entries(data).forEach(([key, value]) => {
					// console.log("Label", data[key].label, data[key].lat, data[key].lng);
					// addMarker(data[key].lat, data[key].lng, 'rgb(255, 0, 0)', data[key].label, dmodelo, MOON_RADIUS, 7, "moonquake");
					// Coordenadas
					if (data[key].year == year && data[key].day == day) {
						var renglon2 = "Year: " + data[key].year + " Day: " + data[key].day;
						var renglon3 = "Time of Detection: " + data[key].timedetection;
						var renglon4 = "Lat: " + data[key].lat + " Long: " + data[key].lng;
						var renglon5 = "Magnitude: " + data[key].intensity;
						var renglon6 = "Detected by station: " + data[key].station;
						addLabelQuake(data[key].lat, data[key].lng, data[key].label, renglon2, renglon3, renglon4, renglon5, renglon6, dmodelo, pathmodels, addremovemoonquake);
						// console.log(data[key].label);
						// console.log(`${key} ${value}`);
					}
				});
				// datos = data;
			}
		}

		function addLabelQuake(lat, lng, renglon1, renglon2, renglon3, renglon4, renglon5, renglon6, models, pathmodels, addremovemoonquake) {
			var y = convertLatLonToVec3(lat, lng).y;
			var x = convertLatLonToVec3(lat, lng).x;
			var z = convertLatLonToVec3(lat, lng).z;
			// Cargamos el modelo 3d
			// console.log(pathmodels, " ", models);
			load3dmodels(x, y, z, pathmodels, models, 7, addremovemoonquake);

			// Titulo
			const earthDiv = document.createElement('div');
			earthDiv.className = 'label';
			earthDiv.textContent = 'Moonquake Name: ' + renglon1;
			earthDiv.style.backgroundColor = '0x000000';
			// earthDiv.style.textColor = '0x000000';

			earthLabel = new CSS2DObject(earthDiv);
			earthLabel.position.set(x, y, z);
			// earthLabel.position.set(convertLatLonToVec3(lat, lon).multiplyScalar(MOON_RADIUS));
			earthLabel.center.set(0, 1);
			moon.add(earthLabel);
			earthLabel.layers.set(7);

			// Año y día
			const earthydDiv = document.createElement('div');
			earthydDiv.className = 'label';
			earthydDiv.textContent = renglon2;
			earthydDiv.style.backgroundColor = '0x000000';
			// earthydDiv.style.backgroundColor = 'transparent';

			earthydLabel = new CSS2DObject(earthydDiv);
			earthydLabel.position.set(x, y, z);
			earthydLabel.center.set(0, 0);
			moon.add(earthydLabel);
			earthydLabel.layers.set(7);

			// Hora
			const earthHDiv = document.createElement('div');
			earthHDiv.className = 'label';
			earthHDiv.textContent = renglon3;
			earthHDiv.style.backgroundColor = '0x000000';
			// earthydDiv.style.backgroundColor = 'transparent';

			earthHLabel = new CSS2DObject(earthHDiv);
			earthHLabel.position.set(x, y, z);
			earthHLabel.center.set(0, -1);
			moon.add(earthHLabel);
			earthHLabel.layers.set(7);

			// Titulo location
			const earthLDiv = document.createElement('div');
			earthLDiv.className = 'label';
			earthLDiv.textContent = "Location:";
			earthLDiv.style.backgroundColor = '0x000000';
			// earthydDiv.style.backgroundColor = 'transparent';

			earthLocabel = new CSS2DObject(earthLDiv);
			earthLocabel.position.set(x, y, z);
			earthLocabel.center.set(0, -2);
			moon.add(earthLocabel);
			earthLocabel.layers.set(7);

			// lat long
			const earthLLDiv = document.createElement('div');
			earthLLDiv.className = 'label';
			earthLLDiv.textContent = renglon4;
			earthLLDiv.style.backgroundColor = '0x000000';
			// earthydDiv.style.backgroundColor = 'transparent';

			earthLLabel = new CSS2DObject(earthLLDiv);
			earthLLabel.position.set(x, y, z);
			earthLLabel.center.set(-0.1, -3);
			moon.add(earthLLabel);
			earthLLabel.layers.set(7);

			// Magnitude
			const earthMDiv = document.createElement('div');
			earthMDiv.className = 'label';
			earthMDiv.textContent = renglon5;
			earthMDiv.style.backgroundColor = '0x000000';
			// earthydDiv.style.backgroundColor = 'transparent';

			earthMabel = new CSS2DObject(earthMDiv);
			earthMabel.position.set(x, y, z);
			earthMabel.center.set(0, -4);
			moon.add(earthMabel);
			earthMabel.layers.set(7);

			// Station
			const earthSDiv = document.createElement('div');
			earthSDiv.className = 'label';
			earthSDiv.textContent = renglon6;
			earthSDiv.style.backgroundColor = '0x000000';
			// earthydDiv.style.backgroundColor = 'transparent';

			earthSabel = new CSS2DObject(earthSDiv);
			earthSabel.position.set(x, y, z);
			earthSabel.center.set(0, -5);
			moon.add(earthSabel);
			earthSabel.layers.set(7);

			// // Marca
			// var marker = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 4), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
			// marker.position.set(x, y, z);
			// scene.add(marker);
			// marker.layers.set(7);
		}

		function moonLandingLoad(MOON_RADIUS, pathmodel, dmodelo) {
			//fetch function Para moon_landing
			// let datos;
			fetch('moon_landings.json').then(
				function (u) { return u.json(); }
			).then(
				function (json) {
					data_function(json); //calling and passing json to another function data_function
				}
			)
			//another functions oon_landing
			function data_function(data) {
				// alert(data.length);

				// addMarker(data[0].lat, data[0].lng, "", data[0].label);
				// Cargamos todo
				Object.entries(data).forEach(([key, value]) => {
					// console.log("Label", data[key].label, data[key].lat, data[key].lng);
					addMarker(data[key].lat, data[key].lng, 'rgb(0, 200, 0)', data[key].label, pathmodel, dmodelo, MOON_RADIUS, 1, "landing");
					// console.log(data[key].label);
					// console.log(`${key} ${value}`);
				});
				// datos = data;
			}
		}
		// Skybox
		function createPathStrings(filename) {
			const basePath = "./img/skybox/";
			const baseFilename = basePath + filename;
			const fileType = ".png";
			const sides = ["ft", "bk", "up", "dn", "rt", "lf"];
			const pathStrings = sides.map((side) => {
				return baseFilename + "_" + side + fileType;
			});
			return pathStrings;
		}

		function createMaterialArray(filename) {
			const skyboxImagepaths = createPathStrings(filename);
			const materialArray = skyboxImagepaths.map((image) => {
				let texture = new THREE.TextureLoader().load(image);
				return new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide }); // <---
			});
			return materialArray;
		}

		function setSkyBox() {
			const materialArray = createMaterialArray(skyboxImage);
			// let temp = new THREE.TextureLoader().load("../img/space_stars_bg.jpg");
			// let temp1 = new THREE.MeshBasicMaterial({ map: temp, side: THREE.BackSide });
			let skyboxGeo = new THREE.BoxGeometry(200, 200, 200);
			skybox = new THREE.Mesh(skyboxGeo, materialArray);
			scene.add(skybox);
		}

		function addMarker(lat, lon, colory, texto, pathmodel, models, MOON_RADIUS, layer, tipo) {
			// tipo landing, seas, moonquake

			var x = convertLatLonToVec3(lat, lon).x;
			var y = convertLatLonToVec3(lat, lon).y;
			var z = convertLatLonToVec3(lat, lon).z;

			// console.log("Tipo", tipo);
			if (tipo == "landing") {
				// load3dmodels(x, y, z, pathmodel, models, 1);

				// const loader = new THREE.CubeTextureLoader();
				// loader.setPath('/img/');

				// const textureCube = loader.load([
				// 	'apollo.png', 'apollo.png',
				// 	'apollo.png', 'apollo.png',
				// 	'apollo.png', 'apollo.png'
				// ]);
				var loaderBox = new THREE.TextureLoader();
				loaderBox.load('img/apollo.png', function (texture) {
					const geometryBox = new THREE.BoxGeometry(0.03, 0.03, 0.03);
					const materialBox = new THREE.MeshBasicMaterial({ color: 0xffffff, map: texture });
					cube = new THREE.Mesh(geometryBox, materialBox);
					cube.position.set(x, y, z);
					cube.layers.set(layer);
					scene.add(cube);
					animate();
				});


				// var loader = new THREE.TextureLoader();
				// loader.load('img/apollo.png', function (texture) {
				// 	const Apollo11 = new THREE.SphereGeometry(0.02, 32, 16);
				// 	const material = new THREE.MeshBasicMaterial({ map: texture, overdraw: 0.01 });
				// 	const sphereApollo = new THREE.Mesh(Apollo11, material);
				// 	sphereApollo.position.set(x, y, z);
				// 	scene.add(sphereApollo);
				// });

				var spritey = makeTextSprite(texto,
					{ fontsize: 40, borderColor: { r: 0, g: 255, b: 0, a: 1.0 }, backgroundColor: { r: 255, g: 100, b: 100, a: 0.8 } });
			}
			else if (tipo == "seas") {
				var spritey = makeTextSprite(texto,
					{ fontsize: 40, borderColor: { r: 0, g: 0, b: 255, a: 1.0 }, backgroundColor: { r: 0, g: 80, b: 100, a: 0.8 } });
			}
			else {
				var spritey = makeTextSprite(texto,
					{ fontsize: 40, borderColor: { r: 255, g: 0, b: 0, a: 1.0 }, backgroundColor: { r: 255, g: 100, b: 100, a: 0.8 } });
			}

			// var marker = new THREE.Mesh(new THREE.SphereGeometry(0.01, 8, 4), new THREE.MeshBasicMaterial({ color: colory }));
			// marker.position.set(x, y, z);
			// scene.add(marker);
			// marker.layers.set(0);

			// console.log(convertLatLonToVec3(60, 0));

			// Label text
			// var spritey = makeTextSprite(texto,
			// 	{ fontsize: 40, borderColor: { r: 255, g: 0, b: 0, a: 1.0 }, backgroundColor: { r: 255, g: 100, b: 100, a: 0.8 } });
			// y green, x red, z blue
			if (tipo != 'moonquake') {
				spritey.position.set(x, y, z);
				spritey.scale.set(0.1, 0.1, 0.1);
				// spritey.position.set(convertLatLonToVec3(lat, lon).multiplyScalar(MOON_RADIUS));
				scene.add(spritey);
				spritey.layers.set(layer);
			}


			// var radius = 100;
			// var marker = new THREE.Mesh(new THREE.SphereGeometry(1, 8, 4), new THREE.MeshBasicMaterial({ color: colory }));
			// // marker.position = convertLatLonToVec3(lat, lon).multiplyScalar(radius);
			// scene.add(marker);
			// Label text
			// var spritey = makeTextSprite(texto,
			// 	{ fontsize: 12, borderColor: { r: 255, g: 0, b: 0, a: 1.0 }, backgroundColor: { r: 255, g: 100, b: 100, a: 0.8 } });
			// // spritey.position.set(-85, 105, 55);
			// spritey.position = convertLatLonToVec3(lat, lon).multiplyScalar(radius);
			// scene.add(spritey);
			// // models.position = convertLatLonToVec3(lat, lon).multiplyScalar(radius);
			// scene.add(models);
		}

		function makeTextSprite(message, parameters) {
			if (parameters == undefined) parameters = {};
			var fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Arial";
			var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 12;
			var borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
			var borderColor = parameters.hasOwnProperty("borderColor") ? parameters["borderColor"] : { r: 0, g: 0, b: 0, a: 1.0 };
			var backgroundColor = parameters.hasOwnProperty("backgroundColor") ? parameters["backgroundColor"] : { r: 255, g: 255, b: 255, a: 1.0 };
			var textColor = parameters.hasOwnProperty("textColor") ? parameters["textColor"] : { r: 0, g: 0, b: 0, a: 1.0 };

			var canvas = document.createElement('canvas');
			var context = canvas.getContext('2d');
			context.font = "Bold " + fontsize + "px " + fontface;
			var metrics = context.measureText(message);
			var textWidth = metrics.width;

			context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
			context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";

			// console.log("Param", backgroundColor.g);

			context.lineWidth = borderThickness;
			roundRect(context, borderThickness / 3, borderThickness / 3, (textWidth + borderThickness) * 1.1, fontsize * 1.4 + borderThickness, 8);

			context.fillStyle = "rgba(" + textColor.r + ", " + textColor.g + ", " + textColor.b + ", 1.0)";
			context.fillText(message, borderThickness, fontsize + borderThickness);

			var texture = new THREE.Texture(canvas)
			texture.needsUpdate = true;

			var spriteMaterial = new THREE.SpriteMaterial({ map: texture, useScreenCoordinates: true });
			var sprite = new THREE.Sprite(spriteMaterial);
			sprite.scale.set(0.5 * fontsize, 0.25 * fontsize, 0.75 * fontsize);
			return sprite;
		}

		// function for drawing rounded rectangles
		function roundRect(ctx, x, y, w, h, r) {
			ctx.beginPath();
			ctx.moveTo(x + r, y);
			ctx.lineTo(x + w - r, y);
			ctx.quadraticCurveTo(x + w, y, x + w, y + r);
			ctx.lineTo(x + w, y + h - r);
			ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
			ctx.lineTo(x + r, y + h);
			ctx.quadraticCurveTo(x, y + h, x, y + h - r);
			ctx.lineTo(x, y + r);
			ctx.quadraticCurveTo(x, y, x + r, y);
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
		}

		function convertLatLonToVec3(lat, lon) {
			lat = lat * Math.PI / 180.0;
			lon = -lon * Math.PI / 180.0;
			var x = Math.cos(lat) * Math.cos(lon);
			var y = Math.sin(lat);
			var z = Math.cos(lat) * Math.sin(lon);
			// console.log(x, y, z);
			return { x, y, z };
			// return new THREE.Vector3(
			// 	Math.cos(lat) * Math.cos(lon),
			// 	Math.sin(lat),
			// 	Math.cos(lat) * Math.sin(lon));
		}

		function load3dmodels(x, y, z, pathmodel, nombre, layer, addremovemoonquake) {
			// model
			// console.log(nombre);

			// new RGBELoader()
			// 	.setPath('/textures/')
			// 	.load('half_earth.hdr', function (texture) {

			// 		texture.mapping = THREE.EquirectangularReflectionMapping;

			// 		scene.background = texture;
			// 		scene.environment = texture;

			// 		// render();

			// 		// model
			if (nombre == "boxApollo.gltf") {
				const loader = new GLTFLoader().setPath(pathmodel);
				loader.load(nombre, function (gltf) {
					model3dCubeApollo = gltf.scene;
					model3dCubeApollo.scale.set(0.01, 0.01, 0.01);
					model3dCubeApollo.position.set(x, y, z);

					scene.add(model3dCubeApollo);
					animate();
					gltf.scene.traverse(function (object) {

						object.layers.set(layer);

					});
				});
			}
			else {
				if (addremovemoonquake == "add") {
					if (model3dquake) {
						scene.remove(model3dquake);
						scene.remove(loaderquake);
						scene.remove(mixeranim);
					}
					loaderquake = new GLTFLoader().setPath(pathmodel);
					loaderquake.setDRACOLoader(dracoLoader);
					loaderquake.load(nombre, function (gltf) {
						model3dquake = gltf.scene;
						// console.log(model3d); // Vemos la info del modelo animaciones, etc
						model3dquake.scale.set(0.04, 0.04, 0.04);
						model3dquake.position.set(x + 0.03, y + 0.03, z + 0.01);
						model3dquake.rotateY(-10);
						model3dquake.rotateX(0);
						model3dquake.rotateZ(80);
						scene.add(model3dquake);

						mixeranim = new THREE.AnimationMixer(model3dquake);
						mixeranim.timeScale = 1 / 7;
						mixeranim.clipAction(gltf.animations[0]).play();

						animate();

						gltf.scene.traverse(function (object) {
							object.layers.set(layer);
						});

					}, undefined, function (e) {
						console.error(e);
					});
					// Creamos un plano y le agregamos una textura animada
					// const geometry = new THREE.PlaneGeometry(1, 1);
					// const material = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide });
					// const plane = new THREE.Mesh(geometry, material);
					// plane.position.set(x, y, z);
					// plane.rotateY(90);
					// scene.add(plane);
				} else {
					if (model3dquake) {
						scene.remove(model3dquake);
						scene.remove(loaderquake);
						scene.remove(mixeranim);
					}
				}
			}
		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;

			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

			labelRenderer.setSize(window.innerWidth, window.innerHeight);

		}

		function moonquakeView(MOON_RADIUS, yMoonquake, dMoonquake, addremovemoonquake) {
			// Antes de recargar los datos destruimos los labels y 3d anim
			// anteriores

			// console.log(yMoonquake);
			// console.log(dMoonquake);

			moon.remove(loaderquake);
			moon.remove(model3dquake);
			moon.remove(mixeranim);
			moon.remove(earthSabel);
			moon.remove(earthSabel);
			moon.remove(earthMabel);
			moon.remove(earthLLabel);
			moon.remove(earthLocabel);
			moon.remove(earthHLabel);
			moon.remove(earthydLabel);
			moon.remove(earthLabel);
			// Volvemos a crear los labels y el 3dmodel
			moonQuakeLoad(MOON_RADIUS, "./3dmodels/", "WaveLightWeightMDDImported.glb", yMoonquake, dMoonquake, addremovemoonquake);
		}

		//
		// function cargarYD() {
		// 	fetch("moon_quakes.json")
		// 		.then(response => {
		// 			return response.json();
		// 		})
		// 		.then(data => yearLista = data);
		// }
		//
		// function initGuib(yearArray, dayArray) {
		// 	var controller;

		// 	var config = {
		// 		'value': '1',
		// 		'changeValues': function () {
		// 			controller.options(['A', 'B', 'C']);
		// 		}
		// 	};

		// 	var gui = new dat.GUI();
		// 	gui.add(config, 'changeValues');
		// 	controller = gui.add(config, 'value', ['1', '2', '3']);
		// 	// gui.remove(controller);

		// 	gui.open();
		// }

		function initGui(yearArray, dayArray) {
			var dayTemp = [];
			var fpsGame, fpsGame, fpsGameVR, aboutTeam, controller, dayMoonquake, searchM;


			var config = {
				'value': '',
				'changeValues': function () {
					controller.options(dayTemp);
					console.log(dayTemp);
				}
			};

			var gui = new dat.GUI({ width: 340 });

			// gui.title('Camera Layers');

			// gui.add(layers, 'Toggle Name');
			// gui.add(layers, 'Toggle Mass');
			// gui.add(layers, 'Enable All');
			// gui.add(layers, 'Disable All');

			// gui.open();

			var parameters =
			{
				a: true, // boolean (checkbox) axes
				b: false, // boolean (checkbox) seas
				c: true, // boolean (checkbox) lat long
				d: false, // boolean (checkbox) landing
				e: false, // boolean (checkbox) moonquake
				f: function () { moonquakeView(MOON_RADIUS, yMoonquake, dMoonquake, "add"); },
				g: true, // Height map
				h: function () { window.open("https://walterm128.github.io/moonquakfps2023/") }, // Moon Game FPS
				i: function () { window.open("about-us.html", "_self") }, // About Team
				j: function () { }, // Texto informativo
				k: function () { }, // Texto informativo
				l: function () { window.open("https://walterm128.github.io/moonquakfpsvr2023/") }, // FPS Moon VR
				m: function () { window.open("graph3d.html", "_self"); }, // graph3d
				n: function () { window.open("https://github.com/walterm128/spaceapp2023/blob/main/obspySismicData.ipynb") }, // Jupyter Notebook
				Rotation: 0,
				AmbientLightIntensity: 0,
				DirectionalLightIntensity: 7,
				DirectionalLightIntensityMove: 0,
				v: 0,    // dummy value, only type is important
				w: "...", // dummy value, only type is important
				// x: 0, y: 0, z: 0
			};
			// gui.add( parameters )
			// gui.add(parameters, 'a').name('Number');
			// gui.add(parameters, 'b').min(128).max(256).step(16).name('Slider');
			// gui.add(parameters, 'c').name('String');

			gui.add(parameters, 'j').name('Info: Hold down the right mouse button - Rotate');
			gui.add(parameters, 'k').name('Info: Hold down the Left mouse button - Move Mouse wheel = Zoom');

			var landingVisible = gui.add(parameters, 'd').name('Hide/Unhide Landing');
			landingVisible.onChange(function (value) {
				camera.layers.toggle(1);
			});

			var visibleAxes = gui.add(parameters, 'a').name('Hide/Unhide Axis');
			visibleAxes.onChange(function (value) {
				if (value == true) {
					camera.layers.toggle(2);
				}
				else {
					camera.layers.toggle(2);
				}
			});

			var visibleSeas = gui.add(parameters, 'b').name('Hide/Unhide Seas');
			visibleSeas.onChange(function (value) {
				camera.layers.toggle(3);
			});

			var visibleWire = gui.add(parameters, 'c').name('Hide/Unhide Lat-Long');
			visibleWire.onChange(function (value) {
				if (value == true) {
					// Textura on
					scene.remove(o);
				}
				else {

					scene.add(o);
				}
			});

			var visibleHeight = gui.add(parameters, 'e').name('Hide/Unhide Moonquakes');
			visibleHeight.onChange(function (value) {
				camera.layers.toggle(7);
				// if (value == true) {
				// 	moon.remove(model3dquake);
				// 	moon.remove(earthSabel);
				// }
				// else {
				// 	moon.add(model3dquake);
				// }
			});

			var visibleHeight = gui.add(parameters, 'g').name('Hide/Unhide Height Map');
			visibleHeight.onChange(function (value) {
				camera.layers.toggle(6);
			});

			// Sliders
			rotationSpeed = gui.add(parameters, "Rotation", 0, 20, 1).name('Rotation Speed');
			ambientLightSlide = gui.add(parameters, "AmbientLightIntensity", 0, 1, 0.01).name('Ambient Light Intensity');
			dirLightSlide = gui.add(parameters, "DirectionalLightIntensity", 0, 7, 0.01).name('Sun Light Intensity');
			dirLightSlideMov = gui.add(parameters, "DirectionalLightIntensityMove", -2, 2, 0.01).name('Sun Light Movement');


			fpsGame = gui.add(parameters, 'h').name('Go To Moon First Person Web Moon');
			fpsGameVR = gui.add(parameters, 'l').name('Go To Moon First Person VR Moon');
			GraphBtn = gui.add(parameters, 'm').name('Go To Graph 3D Moon Quake Intensity');
			GraphBtn = gui.add(parameters, 'n').name('Go To Jupyter Notebook Obspy');
			aboutTeam = gui.add(parameters, 'i').name('Go To About the Team "Space Discovery"');


			// eliminamos duplicados
			var uniqueYear = yearLista.filter((value, index, array) => array.indexOf(value) === index);

			var yearMoonquake = gui.add(parameters, 'v', uniqueYear).name('Year');
			yearMoonquake.onChange(function (value) {
				// gui.destroy();
				yMoonquake = value;
				// Tengo que retornar solo los dias que corresponden a cierto año
				dayTemp = [];
				for (var i = 0; i < yearLista.length; i++) {
					// console.log(dayLista[0]);
					if (yearLista[i] == yMoonquake) {
						dayTemp.push(dayLista[i]);
						// console.log(yMoonquake);
					}
				}
				gui.remove(dayMoonquake);
				gui.remove(searchM);
				// gui.remove(fpsGame);
				// gui.remove(fpsGameVR);
				// gui.remove(aboutTeam);
				// gui.remove(rotationSpeed);
				// gui.remove(GraphBtn);
				// gui.remove(dirLightSlideMov);
				// gui.remove(ambientLightSlide);
				// gui.remove(dirLightSlide);

				//Sliders
				// rotationSpeed = gui.add(parameters, "Rotation", 0, 20, 1).name('Rotation Speed');
				// ambientLightSlide = gui.add(parameters, "AmbientLightIntensity", 0, 1, 0.01).name('Ambient Light Intensity');
				// dirLightSlide = gui.add(parameters, "DirectionalLightIntensity", 0, 7, 0.01).name('Sun Light Intensity');
				// dirLightSlideMov = gui.add(parameters, "DirectionalLightIntensityMove", -2, 2, 0.01).name('Sun Light Movement');

				// fpsGame = gui.add(parameters, 'h').name('Going to the moon in first person Moon!');
				// fpsGameVR = gui.add(parameters, 'l').name('Go To Moon First Person VR Moon');
				// GraphBtn = gui.add(parameters, 'm').name('Graph Moon Quake Intensity');
				// aboutTeam = gui.add(parameters, 'i').name('About the Team');

				dayMoonquake = gui.add(config, 'value', dayTemp).name('Day')
				dayMoonquake.onChange(function (value) {
					dMoonquake = value;
				});

				searchM = gui.add(parameters, 'f').name('Search Moonquake');
			});

			dayMoonquake = gui.add(config, 'value', dayTemp).name('Day')
			dayMoonquake.onChange(function (value) {
				dMoonquake = value;
				moonquakeView(MOON_RADIUS, yMoonquake, dMoonquake, "add");
			});

			// gui.add(config, 'changeValues');
			// controller = gui.add(config, 'value', dayTemp);

			searchM = gui.add(parameters, 'f').name('Search Moonquake');

			rotationSpeed.onChange((value) => {
				// console.log(value);
				rotationSpeedVal = value;
				// if (value == 0) {
				// 	moon.rotateY(0);
				// }
			});

			ambientLightSlide.onChange((value) => {
				// console.log(value);
				ambientLightValue = value;
				// if (value == 0) {
				// 	moon.rotateY(0);
				// }
			});
			dirLightSlideMov.onChange((value) => {
				// console.log(value);
				dirLightValueMovement = value;
				// if (value == 0) {
				// 	moon.rotateY(0);
				// }
			});
			dirLightSlide.onChange((value) => {
				// console.log(value);
				dirLightValue = value;
				// if (value == 0) {
				// 	moon.rotateY(0);
				// }
			});

			// gui.open();
		}
		// Mercer Graph
		function Graph3D() {

		}
		// Destruimos el objeto 3d moonquake y cada label

		function animate() {
			// ojo con mixer, si esta debajo de la funcion requestAnimationFrame
			// no anda el programa
			const delta = clock.getDelta();
			if (mixeranim) { mixeranim.update(delta); }

			if (model3dquake) {
				model3dquake.lookAt(camera.position);
				model3dquake.rotateX(90);
			}
			// if (model3dCubeApollo) {
			// 	model3dCubeApollo.lookAt(camera.position);
			// 	// model3dCubeApollo.rotateX(90);
			// }


			requestAnimationFrame(animate);

			if (scene) {
				scene.rotation.y += rotationSpeedVal / 10000;
				// truco skybox rotation inversa jejejej
				skybox.rotateY(-1 * (rotationSpeedVal / 10000));
				// console.log((rotationSpeedVal / 10000));
			}

			if (lightAmbient) {
				lightAmbient.intensity = ambientLightValue;
			}

			if (lightPoint) {
				lightPoint.intensity = dirLightValue;
			}
			if (lightPoint) {
				// console.log(dirLightValueMovement);
				if (dirLightValueMovement > 0) {
					lightPoint.position.set(2 - dirLightValueMovement, convertLatLonToVec3(0, 0).y, convertLatLonToVec3(0, 0).z + dirLightValueMovement);
				}
				else {
					lightPoint.position.set(dirLightValueMovement + 2, convertLatLonToVec3(0, 0).y, convertLatLonToVec3(0, 0).z + dirLightValueMovement);
				}

			}

			// if (cube) {
			// 	cube.lookAt(camera.position);
			// }
			// if (textureMeshScale) {
			// 	textureMeshScale.lookAt(camera.position);
			// 	// textureMeshScale.rotation.y = 90;
			// 	// scaleGeometry.translate(0.5, 0, -1.1);
			// 	// textureMeshScale.position.set(0.5, 0, -1.1);
			// 	// textureMeshScale.rotateX(0);
			// 	// textureMeshScale.rotateZ(90);
			// }

			const elapsed = clock.getElapsedTime();

			// stats.update();

			// moon.position.set(Math.sin(elapsed) * 5, 0, Math.cos(elapsed) * 5);

			renderer.render(scene, camera);
			labelRenderer.render(scene, camera);

		}

	</script>
</body>

</html>